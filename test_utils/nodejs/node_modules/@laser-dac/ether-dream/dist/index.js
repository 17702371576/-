"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EtherConn = exports.EtherDream = void 0;
const dgram = require("dgram");
const EtherConn_1 = require("./EtherConn");
Object.defineProperty(exports, "EtherConn", { enumerable: true, get: function () { return EtherConn_1.EtherConn; } });
const parse_1 = require("./parse");
const core_1 = require("@laser-dac/core");
const convert_1 = require("./convert");
const DEFAULT_POINTS_RATE = 30000;
class EtherDream extends core_1.Device {
    async search() {
        const manualAddress = process.env.ETHER_ADDRESS;
        if (manualAddress) {
            const [ip, port] = manualAddress.split(':');
            return { ip, port: parseInt(port) };
        }
        else {
            const devices = await EtherDream.findFirst();
            return devices[0];
        }
    }
    async start() {
        const device = await this.search();
        if (!device) {
            return false;
        }
        const conn = await EtherDream.connect(device.ip, device.port);
        if (conn) {
            this.connection = conn;
            return true;
        }
        return false;
    }
    stop() {
        if (this.connection) {
            this.connection.sendEmergencyStop(() => {
                if (this.connection) {
                    this.connection.close();
                }
            });
        }
    }
    convertPoint(p) {
        return {
            x: (0, convert_1.relativeToPosition)(p.x),
            y: (0, convert_1.relativeToPosition)(p.y),
            r: (0, convert_1.relativeToColor)(p.r),
            g: (0, convert_1.relativeToColor)(p.g),
            b: (0, convert_1.relativeToColor)(p.b),
        };
    }
    stream(scene, pointsRate = DEFAULT_POINTS_RATE) {
        if (!this.connection) {
            throw new Error('No active connection to the Ether Dream, call start() first');
        }
        this.connection.streamFrames(pointsRate, (callback) => {
            const points = scene.points.map(this.convertPoint);
            callback(points);
        });
    }
}
exports.EtherDream = EtherDream;
EtherDream._find = function (limit, timeout) {
    const ips = [];
    const devices = [];
    const server = dgram.createSocket('udp4');
    return new Promise((resolve) => {
        const timeouttimer = setTimeout(function () {
            server.close();
            resolve(devices);
        }, timeout);
        server.on('message', function (msg, rinfo) {
            const ip = rinfo.address;
            if (ips.indexOf(ip) != -1)
                return;
            ips.push(ip);
            const name = 'EtherDream @ ' +
                (0, parse_1.twohex)(msg[0]) +
                ':' +
                (0, parse_1.twohex)(msg[1]) +
                ':' +
                (0, parse_1.twohex)(msg[2]) +
                ':' +
                (0, parse_1.twohex)(msg[3]) +
                ':' +
                (0, parse_1.twohex)(msg[4]) +
                ':' +
                (0, parse_1.twohex)(msg[5]);
            devices.push({
                ip: ip,
                port: 7765,
                name: name,
                hw_revision: msg[6],
                sw_revision: msg[7],
            });
            if (devices.length >= limit) {
                server.close();
                clearTimeout(timeouttimer);
                resolve(devices);
            }
        });
        server.on('error', () => {
            server.close();
            clearTimeout(timeouttimer);
            resolve(devices);
        });
        server.bind(7654);
        // wait two seconds for data to come back...
    });
};
EtherDream.find = function () {
    return EtherDream._find(99, 2000);
};
EtherDream.findFirst = function () {
    return EtherDream._find(1, 4000);
};
EtherDream.connect = function (ip, port) {
    const conn = new EtherConn_1.EtherConn();
    return conn.connect(ip, port).then((success) => (success ? conn : null));
};
