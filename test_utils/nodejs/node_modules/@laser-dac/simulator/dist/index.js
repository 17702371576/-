"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Simulator = void 0;
const ws_1 = require("ws");
const core_1 = require("@laser-dac/core");
const helpers_1 = require("./helpers");
const express = require("express");
const path = require("path");
const http = require("http");
// When there is no real device, we fake an interval.
// We've measured how fast the real device streams, which was 4ms.
const STREAM_INTERVAL = 4;
// How many points are drawn at the same time.
// Increasing the number leads to a more stable image with less flickering.
// Only used for the simulator!
const REQUESTED_POINTS_COUNT = 500;
const PORT = 8080;
class Simulator extends core_1.Device {
    constructor() {
        super(...arguments);
        // This method is called soo often, so throttle it!
        this.sendPointInfoToSimulator = (0, helpers_1.throttle)((numpoints, totalPoints) => {
            this.sendToSimulator({
                type: 'POINTS_INFO',
                data: { numpoints, totalPoints },
            });
        }, 400);
    }
    start() {
        return new Promise((resolve, reject) => {
            this.server = http.createServer();
            const app = express();
            app.use(express.static(path.join(__dirname, '..', 'public')));
            this.wss = new ws_1.Server({ server: this.server });
            this.server.on('request', app);
            this.server.listen(PORT, function () {
                console.log(`Started simulator on http://localhost:${PORT}`);
                resolve(true);
            });
        });
    }
    stop() {
        if (this.server) {
            this.server.close();
        }
        this.stopInterval();
    }
    stopInterval() {
        if (this.interval) {
            clearInterval(this.interval);
        }
    }
    stream(scene, pointsRate) {
        this.stopInterval();
        const self = this;
        const frameBuffer = [];
        function innerStream(numpoints, pointcallback) {
            if (frameBuffer.length < numpoints) {
                const points = scene.points;
                for (let i = 0; i < points.length; i++) {
                    frameBuffer.push(points[i]);
                }
                // get another frame if we need to...
                setTimeout(innerStream.bind(self, numpoints, pointcallback), 0);
                self.sendPointInfoToSimulator(numpoints, points.length);
            }
            else {
                const points = frameBuffer.splice(0, numpoints);
                pointcallback(points);
            }
        }
        this.interval = setInterval(() => {
            innerStream(REQUESTED_POINTS_COUNT, (streamPoints) => {
                this.sendPointsToSimulator(streamPoints);
            });
        }, STREAM_INTERVAL);
    }
    sendToSimulator(data) {
        this.wss.clients.forEach((client) => {
            client.send(JSON.stringify(data), function () {
                // Ignore errors for now
            });
        });
    }
    sendPointsToSimulator(data) {
        this.sendToSimulator({ type: 'POINTS', data });
    }
}
exports.Simulator = Simulator;
