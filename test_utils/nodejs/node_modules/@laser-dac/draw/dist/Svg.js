"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadSvgFile = exports.Svg = void 0;
const fs = require("fs");
const Shape_1 = require("./Shape");
const svg_parser_1 = require("svg-parser");
const Path_1 = require("./Path");
const helpers_1 = require("./helpers");
const constants_1 = require("./constants");
const DEFAULT_COLOR = [0, 1, 0];
const ALLOWED_NODES = ['path', 'polyline', 'polygon', 'rect', 'line'];
class Svg extends Shape_1.Shape {
    constructor(options) {
        super();
        this.pathNodes = [];
        this.nodeWalker = (child) => {
            if (ALLOWED_NODES.includes(child.name)) {
                this.pathNodes.push(child);
            }
            else if (child.children) {
                child.children.forEach(this.nodeWalker);
            }
        };
        this.x = options.x;
        this.y = options.y;
        this.file = options.file;
        this.color = options.color || DEFAULT_COLOR;
        this.size = options.size || 1;
        this.waitAmount = options.waitAmount || constants_1.MAX_WAIT_AMOUNT;
        this.blankingAmount = options.blankingAmount || constants_1.BLANKING_AMOUNT;
    }
    parseViewBox(raw) {
        raw = raw || '0 0 1 1';
        const values = raw.split(' ');
        if (values.length !== 4) {
            throw new Error('SVG parser: Invalid viewBox given');
        }
        return {
            minX: parseFloat(values[0]),
            minY: parseFloat(values[1]),
            width: parseFloat(values[2]),
            height: parseFloat(values[3]),
        };
    }
    parseHexToRelativeColor(color) {
        const rgb = (0, helpers_1.hexToRgb)(color);
        if (rgb) {
            return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255];
        }
        return this.color;
    }
    draw(resolution) {
        const viewBox = this.parseViewBox(String(this.file.attributes.viewBox));
        const aspectRatio = viewBox.width / viewBox.height;
        const width = viewBox.width / this.size;
        const height = (aspectRatio * viewBox.height) / this.size;
        this.pathNodes = [];
        this.nodeWalker(this.file);
        const points = this.pathNodes.map((_node) => {
            const node = convertToPath(_node);
            const color = node.attributes.stroke || node.attributes.fill;
            return new Path_1.Path({
                path: node.attributes.d,
                color: this.parseHexToRelativeColor(color),
                x: this.x,
                y: this.y,
                width,
                height,
                waitAmount: this.waitAmount,
                blankingAmount: this.blankingAmount,
            }).draw(resolution);
        });
        return (0, helpers_1.flatten)(points);
    }
}
exports.Svg = Svg;
function loadSvgFile(path) {
    const buffer = fs.readFileSync(path);
    const content = buffer.toString();
    return (0, svg_parser_1.parse)(content);
}
exports.loadSvgFile = loadSvgFile;
// Many SVG elements can be replaced to <path/>, which makes life easier for us.
function convertToPath(node) {
    if (node.name === 'polyline' || node.name === 'polygon') {
        node.attributes.d = `M${node.attributes.points}`;
        if (node.name === 'polygon')
            node.attributes.d += 'z';
        node.name = 'path';
        node.attributes.points = '';
    }
    else if (node.name === 'rect') {
        const x = +node.attributes.x;
        const y = +node.attributes.y;
        const width = +node.attributes.width;
        const height = +node.attributes.height;
        // TODO: this only works when the "px" postfix is not used
        // TODO: Calculate sizes from % and non-px units if possible.
        if (isNaN(x - y + width - height))
            return node;
        node.name = 'path';
        node.attributes.d = `M${x} ${y}H${x + width}V${y + height}H${x}z`;
        node.attributes.x = '';
        node.attributes.y = '';
        node.attributes.width = '';
        node.attributes.height = '';
    }
    else if (node.name === 'line') {
        const x1 = +node.attributes.x1;
        const y1 = +node.attributes.y1;
        const x2 = +node.attributes.x2;
        const y2 = +node.attributes.y2;
        if (isNaN(x1 - y1 + x2 - y2))
            return node;
        node.name = 'path';
        node.attributes.d = `M${x1} ${y1}L${x2} ${y2}`;
        node.attributes.x1 = '';
        node.attributes.y1 = '';
        node.attributes.x2 = '';
        node.attributes.y2 = '';
    }
    // TODO: implement circle/ellipse
    // very easy, see: https://github.com/svg/svgo/blob/master/plugins/convertShapeToPath.js#L67
    return node;
}
