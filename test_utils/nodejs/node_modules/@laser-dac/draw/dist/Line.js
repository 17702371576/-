"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Line = void 0;
const Shape_1 = require("./Shape");
const Point_1 = require("./Point");
const Wait_1 = require("./Wait");
const constants_1 = require("./constants");
class Line extends Shape_1.Shape {
    constructor(options) {
        super();
        this.from = options.from;
        this.to = options.to;
        this.color = options.color;
        this.blankBefore = options.blankBefore || false;
        this.blankAfter = options.blankAfter || false;
        this.waitAmount = options.waitAmount || constants_1.MAX_WAIT_AMOUNT;
        this.blankingAmount = options.blankingAmount || constants_1.BLANKING_AMOUNT;
    }
    draw(resolution) {
        const distanceX = this.from.x - this.to.x;
        const distanceY = this.from.y - this.to.y;
        // Calculate distance using the Pythagorean theorem.
        const distance = Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));
        const steps = Math.round(distance * resolution);
        let points = [];
        if (this.blankBefore) {
            // Add blanking points.
            points = new Wait_1.Wait({
                x: this.from.x,
                y: this.from.y,
                color: [0, 0, 0],
                amount: this.blankingAmount,
            }).draw();
        }
        for (let stepNumber = 1; stepNumber <= steps; stepNumber++) {
            points.push(new Point_1.Point(this.from.x - (distanceX / steps) * stepNumber, this.from.y - (distanceY / steps) * stepNumber, this.color));
        }
        if (this.blankAfter) {
            // Add blanking points.
            points = [
                ...points,
                ...new Wait_1.Wait({
                    x: this.to.x,
                    y: this.to.y,
                    color: this.color,
                    amount: this.waitAmount / 2,
                }).draw(),
            ];
        }
        return points;
    }
}
exports.Line = Line;
