"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadIldaFile = exports.Ilda = exports.convertCoordinate = exports.XY_RESOLUTION = void 0;
const fs = require("fs");
const ilda_reader_1 = require("@laser-dac/ilda-reader");
const Shape_1 = require("./Shape");
exports.XY_RESOLUTION = 65535;
function convertCoordinate(n) {
    return -(2 * n - exports.XY_RESOLUTION) / (exports.XY_RESOLUTION * 2);
}
exports.convertCoordinate = convertCoordinate;
class Ilda extends Shape_1.Shape {
    constructor(options) {
        super();
        this.x = options.x;
        this.y = options.y;
        this.size = options.size;
        this.color = options.color;
        this.frame = options.frame;
        this.file = options.file;
    }
    draw() {
        const section = this.file.sections[this.frame];
        const x = this.x || 0;
        const y = this.y || 0;
        const color = this.color;
        const size = this.size || 1;
        return section.points.map((point) => {
            const isBlank = point.r === 0 && point.g === 0 && point.b === 0;
            return {
                x: x + (1 - convertCoordinate(point.x)) * size,
                y: y + convertCoordinate(point.y) * size,
                r: color !== undefined && !isBlank ? color[0] : point.r,
                g: color !== undefined && !isBlank ? color[1] : point.g,
                b: color !== undefined && !isBlank ? color[2] : point.b,
            };
        });
    }
}
exports.Ilda = Ilda;
function loadIldaFile(path) {
    const buffer = fs.readFileSync(path);
    const byteArray = Array.prototype.slice.call(buffer, 0);
    return { sections: (0, ilda_reader_1.fromByteArray)(byteArray) };
}
exports.loadIldaFile = loadIldaFile;
