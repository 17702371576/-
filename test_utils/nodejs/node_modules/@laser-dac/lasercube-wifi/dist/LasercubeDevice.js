"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LasercubeDevice = void 0;
const struct = require("python-struct");
const _1 = require(".");
const data_1 = require("./data");
const delay = (t) => new Promise((resolve) => setTimeout(resolve, t));
class LasercubeDevice {
    constructor(address, cmdSocket, dataSocket) {
        this.running = true;
        // How much free buffer the device has
        this.remoteBufFree = 0;
        this.dacRate = 30000;
        this.info = null;
        this.handleCmdMessage = (msg, rinfo) => {
            if (msg[0] === data_1.Command.GetFullInfo) {
                const fields = struct.unpack('<xxBB?5xIIxHHBBB11xB26x', msg);
                this.info = {
                    outputEnabled: fields[2],
                    dacRate: fields[3],
                    maxDacRate: fields[4],
                    rxBufferFree: fields[5],
                    rxBufferSize: fields[6],
                    batteryPercent: fields[7],
                    temperature: fields[8],
                };
                this.remoteBufFree = this.info.rxBufferFree;
                this.dacRate = this.info.dacRate;
            }
        };
        this.handleDataMessage = (msg, rinfo) => {
            if (msg[0] === data_1.Command.GetRingBufferEmptySampleCount) {
                this.remoteBufFree = struct.unpack('<xxH', msg)[0];
            }
        };
        // How many messages were sent to the data socket (needs to be sequential)
        this.messageNum = 0;
        // How many frames were sent to the data socket
        this.frameNum = 0;
        this.streamCallback = null;
        this.run = async () => {
            if (!this.running)
                return;
            if (!this.streamCallback) {
                await delay(0);
                this.run();
                return;
            }
            const frame = this.streamCallback();
            while (frame.length > 0 && this.running) {
                // If the remote buffer is already partially full, wait a bit.
                // When to wait determines your latency/stability tradeoff. The
                // more of the buffer you use, the more easily you'll deal with
                // network hiccups slowness but the farther you'll be scheduling
                // stuff ahead of real time. On my LaserCube, the buffer is 6000
                // points and 5000 (i.e. only trying to use the first 1000 slots
                // in the buffer) was chosen through trial and error as
                // providing good stable output but keeping latency around
                // 1/30s.
                if (this.remoteBufFree < 5000) {
                    const buffWait = this.remoteBufFree < 1500 ? 500 : 120;
                    await delay((buffWait * 1000) / this.dacRate);
                    this.remoteBufFree += buffWait;
                }
                const firstMsg = Buffer.from([
                    data_1.Command.SampleData,
                    0x00,
                    this.messageNum % 0xff,
                    this.frameNum % 0xff,
                ]);
                // Limiting to 140 points per message keeps messages under 1500
                // bytes, which is a common network MTU.
                const firstPoints = frame.splice(0, 140);
                this.remoteBufFree -= firstPoints.length;
                const msg = Buffer.concat([firstMsg, ...firstPoints]);
                try {
                    this.dataSocket.send(msg, _1.LasercubeWifi.dataPort, this.address);
                }
                catch (_a) {
                    // Ignore errors that happened during sending for now
                }
                this.messageNum += 1;
            }
            this.frameNum += 1;
            if (!frame.length) {
                await delay(0);
            }
            this.run();
        };
        this.address = address;
        this.cmdSocket = cmdSocket;
        this.dataSocket = dataSocket;
    }
    stop() {
        this.running = false;
        this.sendCommand(data_1.Command.EnableBufferSizeResponseOnData, 0x0);
        this.sendCommand(data_1.Command.SetOutput, 0x0);
        this.cmdSocket.off('message', this.handleCmdMessage);
        this.dataSocket.off('message', this.handleDataMessage);
    }
    sendCommand(cmd, value) {
        const msg = Buffer.from([cmd, value]);
        this.cmdSocket.send(msg, _1.LasercubeWifi.cmdPort, this.address);
        // Send it a second time to increase chances the message arrives
        this.cmdSocket.send(msg, _1.LasercubeWifi.cmdPort, this.address);
    }
    start() {
        this.cmdSocket.on('message', this.handleCmdMessage);
        this.dataSocket.on('message', this.handleDataMessage);
        this.sendCommand(data_1.Command.EnableBufferSizeResponseOnData, 0x1);
        this.sendCommand(data_1.Command.SetOutput, 0x1);
        this.messageNum = 0;
        this.frameNum = 0;
        this.streamCallback = null;
        this.run();
    }
    streamFrames(dacRate, callback) {
        this.dacRate = dacRate;
        this.streamCallback = callback;
    }
}
exports.LasercubeDevice = LasercubeDevice;
