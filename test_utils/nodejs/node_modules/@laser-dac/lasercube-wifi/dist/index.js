"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LasercubeWifi = void 0;
const dgram = require("dgram");
const core_1 = require("@laser-dac/core");
const LasercubeScanner_1 = require("./LasercubeScanner");
const convert_1 = require("./convert");
const struct = require("python-struct");
const DEFAULT_POINTS_RATE = 30000;
class LasercubeWifi extends core_1.Device {
    constructor() {
        super(...arguments);
        this.cmdSocket = dgram.createSocket('udp4');
        this.dataSocket = dgram.createSocket('udp4');
    }
    async search() {
        this.scanner = new LasercubeScanner_1.LasercubeScanner(this.cmdSocket, this.dataSocket);
        return await this.scanner.search(4000);
    }
    async start() {
        this.startSockets();
        const device = await this.search();
        if (!device) {
            return false;
        }
        this.device = device;
        this.device.start();
        return true;
    }
    stop() {
        if (this.scanner) {
            this.scanner.stop();
        }
        if (this.device) {
            this.device.stop();
        }
        this.stopSockets();
    }
    startSockets() {
        this.cmdSocket.on('error', (err) => {
            console.error('Lasercube WiFi cmd socket error:', err);
            this.stop();
        });
        this.cmdSocket.bind(LasercubeWifi.cmdPort, undefined, () => {
            this.cmdSocket.setBroadcast(true);
        });
        this.dataSocket.on('error', (err) => {
            console.error('Lasercube WiFi data socket error:', err);
            this.stop();
        });
        this.dataSocket.bind(LasercubeWifi.dataPort);
    }
    stopSockets() {
        try {
            this.cmdSocket.close();
            this.dataSocket.close();
            // Ignore errors about socket already being closed
        }
        catch (_a) { }
    }
    convertPoint(p) {
        const x = (0, convert_1.relativeToPosition)(p.x);
        const y = (0, convert_1.relativeToPosition)(p.y);
        const r = (0, convert_1.relativeToColorRed)(p.r);
        const g = (0, convert_1.relativeToColorGreen)(p.g);
        const b = (0, convert_1.relativeToColorBlue)(p.b);
        // Pack it into a C++ compatible binary struct
        return struct.pack('<HHHHH', x, y, r, g, b);
    }
    stream(scene, pointsRate = DEFAULT_POINTS_RATE) {
        if (!this.device) {
            console.error('No device found while streaming');
            return;
        }
        this.device.streamFrames(pointsRate, () => {
            const points = scene.points.map(this.convertPoint);
            return points;
        });
    }
}
exports.LasercubeWifi = LasercubeWifi;
LasercubeWifi.cmdPort = 45457;
LasercubeWifi.dataPort = 45458;
